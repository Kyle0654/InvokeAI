"""Views module."""
import base64
from copy import copy
import json
import os
from queue import Queue
import threading
from flask import current_app, jsonify, request, Response, send_from_directory, stream_with_context, url_for
from flask.views import MethodView
from numpy import empty
from dependency_injector.wiring import inject, Provide

from ldm.dream.models import DreamRequest
from ldm.dream.pngwriter import PngWriter
from ldm.dream.server import CanceledException
from ldm.dream.services import GeneratorService
from ldm.dream.containers import Container
from ldm.simplet2i import T2I

class WebIndex(MethodView):
  init_every_request = False
  
  def get(self):
    return current_app.send_static_file('index.html')

  @inject
  def post(self, generator_service: GeneratorService = Provide[Container.generator_service]):
    dreamRequest = DreamRequest.from_json(request.json, generator_service.model())

    #self.canceled.clear()
    print(f">> Request to generate with prompt: {dreamRequest.prompt}")
    # In order to handle upscaled images, the PngWriter needs to maintain state
    # across images generated by each call to prompt2img(), so we define it in
    # the outer scope of image_done()
    config = copy(dreamRequest)
    config.initimg = ''

    q = Queue()

    images_generated = 0    # helps keep track of when upscaling is started
    images_upscaled = 0     # helps keep track of when upscaling is completed
    pngwriter = PngWriter("./outputs/img-samples/")

    prefix = pngwriter.unique_prefix()
    # if upscaling is requested, then this will be called twice, once when
    # the images are first generated, and then again when after upscaling
    # is complete. The upscaling replaces the original file, so the second
    # entry should not be inserted into the image list.
    def image_done(image, seed, upscaled=False):
        name = f'{prefix}.{seed}.png'
        path = pngwriter.save_image_and_prompt_to_png(image, f'{dreamRequest.prompt} -S{seed}', name)

        # Append post_data to log, but only once!
        if not upscaled:
            with open("./outputs/img-samples/dream_web_log.txt", "a") as log:
                log.write(f"{path}: {config.to_json()}\n")

            # TODO: get path from Flask
            imgpath = f"/api/images/{name}"
            q.put({
              'type': 'result',
              'data': {'event': 'result', 'url': imgpath, 'seed': seed, 'config': config.__dict__}
            })

        # control state of the "postprocessing..." message
        upscaling_requested = dreamRequest.upscale or dreamRequest.gfpgan_strength>0
        nonlocal images_generated # NB: Is this bad python style? It is typical usage in a perl closure.
        nonlocal images_upscaled  # NB: Is this bad python style? It is typical usage in a perl closure.
        if upscaled:
            images_upscaled += 1
        else:
            images_generated +=1
        if upscaling_requested:
            action = None
            if images_generated >= dreamRequest.iterations:
                if images_upscaled < dreamRequest.iterations:
                    action = 'upscaling-started'
                else:
                    action = 'upscaling-done'
            if action:
                x = images_upscaled+1
                q.put({
                  'type': 'progress' if (action == 'upscaling-started') else 'done',
                  'data': {'event':action,'processed_file_cnt':f'{x}/{dreamRequest.iterations}'}
                })

    step_writer = PngWriter('./outputs/intermediates/')
    step_index = 1
    def image_progress(sample, step):
        # if self.canceled.is_set(): # TODO: Handle cancellation
        #     self.wfile.write(bytes(json.dumps({'event':'canceled'}) + '\n', 'utf-8'))
        #     raise CanceledException
        path = None
        # since rendering images is moderately expensive, only render every 5th image
        # and don't bother with the last one, since it'll render anyway
        nonlocal step_index
        if dreamRequest.progress_images and step % 5 == 0 and step < dreamRequest.steps - 1:
            image = generator_service.model()._sample_to_image(sample)
            name = f'{prefix}.{dreamRequest.seed}.{step_index}.png'
            metadata = f'{dreamRequest.prompt} -S{dreamRequest.seed} [intermediate]'
            path = step_writer.save_image_and_prompt_to_png(image, metadata, name)
            step_index += 1

        q.put({
          'type': 'progress',
          'data': {'event': 'step', 'step': step + 1, 'url': path}
        })

    def generateImage(dreamRequest: DreamRequest, progress_callback, done_callback):
      try:
        if dreamRequest.initimg is None:
            # Run txt2img
            generator_service.model().prompt2image(dreamRequest.prompt,
                                    iterations=dreamRequest.iterations,
                                    cfg_scale = dreamRequest.cfgscale,
                                    width = dreamRequest.width,
                                    height = dreamRequest.height,
                                    seed = dreamRequest.seed,
                                    steps = dreamRequest.steps,
                                    gfpgan_strength = dreamRequest.gfpgan_strength,
                                    upscale         = dreamRequest.upscale,
                                    sampler_name    = dreamRequest.sampler_name,
                                    step_callback=progress_callback,
                                    image_callback=done_callback)
        else:
            # Decode initimg as base64 to temp file
            with open("./img2img-tmp.png", "wb") as f:
                initimg = dreamRequest.initimg.split(",")[1] # Ignore mime type
                f.write(base64.b64decode(initimg))

            try:
                # Run img2img
                generator_service.model().prompt2image(dreamRequest.prompt,
                                        init_img = "./img2img-tmp.png",
                                        strength = dreamRequest.strength,
                                        iterations = dreamRequest.iterations,
                                        cfg_scale  = dreamRequest.cfgscale,
                                        seed       = dreamRequest.seed,
                                        steps      = dreamRequest.steps,
                                        sampler_name    = dreamRequest.sampler_name,
                                        width      = dreamRequest.width,
                                        height     = dreamRequest.height,
                                        fit        = dreamRequest.fit,
                                        gfpgan_strength=dreamRequest.gfpgan_strength,
                                        upscale         = dreamRequest.upscale,
                                        step_callback=progress_callback,
                                        image_callback=done_callback)
            finally:
                # Remove the temp file
                os.remove("./img2img-tmp.png")

      except CanceledException:
          q.put({
            'type': 'cancelled',
            'data': {}
          })
          return
      
      finally:
        q.put({ 'type': 'done' })

    th = threading.Thread(target=generateImage, args=(dreamRequest, image_progress, image_done))
    th.start()

    def generateResponse():
      while th.is_alive or not q.empty():
        event = q.get()
        if event['type'] == 'progress':
          yield f"{json.dumps(event['data'])}\n"

        elif event['type'] == 'result':
          yield f"{json.dumps(event['data'])}\n"

        elif event['type'] == 'canceled':
          yield f"{json.dumps(event['data'])}\n"
          break

        elif event['type'] == 'done':
          break

    return Response(stream_with_context(generateResponse()))
  

class WebConfig(MethodView):
  init_every_request = False

  def get(self):
    # unfortunately this import can't be at the top level, since that would cause a circular import
    from ldm.gfpgan.gfpgan_tools import gfpgan_model_exists
    config = {
        'gfpgan_model_exists': gfpgan_model_exists
    }
    js = f"let config = {json.dumps(config)};\n"
    return Response(js, mimetype="application/javascript")

class ApiIndex(MethodView):
  init_every_request = False
  generator_service = None

  @inject
  def __init__(self, generator_service: GeneratorService = Provide[Container.generator_service]):
    self.generator_service = generator_service

  @inject
  def get(self):
    return jsonify({ "result": self.generator_service.hello() })

class ApiCancel(MethodView):
  init_every_request = False
  
  def get(self):
    # self.canceled.set()
    return jsonify({})

class ApiOutputs(MethodView):
  init_every_request = False
  pathRoot = None

  def __init__(self, pathBase):
    self.pathRoot = os.path.abspath(os.path.join(os.path.dirname(__file__), f'../../outputs/{pathBase}'))

  def get(self, name):
    return send_from_directory(self.pathRoot, name)

# @app.route('/api')
# def index():
#   return "Hello, World"
